# 1월1일 그리디 골드 5
# A와 B

S = list(input())
T = list(input())

# print(S,T)

# Top - down 방식 풀이

dap = False

while T:

    if T[-1] == 'A':
        T.pop()

    elif T[-1] == 'B':
        T.pop()
        T.reverse()

    if S == T:
        dap = True
        break

if dap:
    print(1)
else:
    print(0)

# 알게 된 점
'''
무언가를 a->b로 바꾸는 유형의 문제가 많은 것 같다. 
top - down 형식으로 문제를 접근하면 쉽게 풀렸다.

이 문제와 그리디는 어떠한 연관이 있는지 조사



1. 반례 for문으로 a, b를 바꾸는 로직에서 반례 생겼음 

2. 리스트의 요소 a,b을 서로 바꾸는 방법 2가지
.revers() 이용

슬라이싱 이용
my_list = [1, 2, 3, 4, 5]
reversed_list = my_list[::-1]
print(reversed_list)  # 출력: [5, 4, 3, 2, 1]

'''


'''
Top-Down 접근: 이 문제에서는 S를 시작점으로 삼고, T가 될 수 있는지를 검사. 이는 문제를 작은 부분으로 나누어 해결하는 일반적인 "Top-down" 접근법을 따릅니다. 
S에서 시작하여 각 단계에서 가능한 조작을 적용하면서 최종적으로 T에 도달할 수 있는지 확인.

그리디 알고리즘과의 관계: 그리디 알고리즘은 각 단계에서 "로컬 최적"의 선택을 하는 방식으로 문제를 해결하는 알고리즘입니다. 

이 문제에서는 그리디 알고리즘의 전형적인 접근법과는 다소 차이가 있습니다. 
그리디 알고리즘은 일반적으로 "현재 상태에서 최선의 선택"을 기반으로 합니다. 
반면, 이 문제의 해결 방식은 현재 상태에서 가능한 모든 선택(예: 문자 'A' 또는 'B'를 추가)을 고려하여 T에 도달할 수 있는지를 검사합니다. 
따라서, 이 문제의 해결 방식은 전형적인 그리디 접근법보다는 브루트포스(brute-force) 또는 백트래킹(backtracking)에 가깝습니다.

결론: 이 문제의 해결 방식은 그리디 알고리즘의 전형적인 "현재 최선의 선택만을 고려"하는 방식과는 다르게, 가능한 모든 선택을 고려합니다. 따라서, 이 문제를 그리디 알고리즘의 예시로 보기는 어렵습니다. 그보다는 브루트포스나 백트래킹에 더 가까운 접근 방식으로 볼 수 있습니다.

'''
