# 12월 30일 행렬
'''
0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.

행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)
'''

# A -> B

# 이 풀이는 그리디 보다 완전 탐색에 가깝다

r, c = map(int, input().split())

a = []
b = []

for i in range(r):
    a.append(list(map(int, (input()))))

for i in range(r):
    b.append(list(map(int, (input()))))

# print(a, b)


def check():  # b행렬과 a행렬을 비교하는 함수
    for i in range(r):
        for j in range(c):
            if a[i][j] != b[i][j]:
                return False
    return True


def reverse(x, y):  # 기준점 (x,y)에서 3x3의 부분을 뒤집는 함수
    for i in range(x, x+3):
        for j in range(y, y+3):
            a[i][j] = 1 - a[i][j]  # 뒤집기


count = 0

for i in range(r-2):
    for j in range(c-2):  # 3x3 인덱스 경계값 철저히
        if a[i][j] != b[i][j]:  # 단순히 서로 다르면
            # 뒤집기 기준을 왼쪽 맨위로 지정 (보통 뒤집는 것의 중심을 가운데로 두는데, 이렇게하면 인덱스 처리가 어려워 질듯)
            reverse(i, j)
            count += 1

if check():
    print(count)
else:
    print(-1)


'''
개인적으로 그리디 보다 완전탐색에 가깝다고 생각했다. 
모든 행렬을 순회하며 비교하며 단순히 다를 시 바꾸어주는 로직 이라고 느껴지기 때문에

-> 틀린 생각이였다. 더욱 공부할 필요를 느낌

-> 그리디의 개념, 완전 탐색의 개념, DP의 개념 정립 필요

gpt 답변

제시된 코드는 실제로 그리디(greedy) 알고리즘의 원리를 사용 그리디 알고리즘은 각 단계에서 최적의 해결책을 선택하는 방식으로, 여기서는 "현재 위치에서 두 행렬의 값이 다르다면 뒤집기"라는 간단한 규칙을 따릅니다. 

로컬 최적 해 선택: 각 단계에서, 행렬 A와 B가 다른 지점을 찾아 해당 지점을 기준으로 하는 3x3 부분 행렬을 뒤집습니다. 이는 그 순간에 가장 "좋은" 해결책, 즉 로컬 최적 해를 선택하는 것입니다.

부분 문제의 독립성: 각 단계의 결정은 다른 부분 문제들과 독립적입니다. 즉, 한 지점에서의 뒤집기 연산이 다른 지점에 대한 결정에 영향을 미치지 않습니다.

최종 결과 도출: 모든 가능한 3x3 부분에 대해 이 과정을 반복하며, 최종적으로 행렬 A를 B로 변환합니다. 이는 그리디 알고리즘이 "각 단계에서 최적의 해를 선택하면 최종적으로 전체 문제의 최적 해를 얻을 수 있다"는 가정에 기반합니다.

단순히 모든 요소를 순회하며 만날때마다 바꾸는 방법이 최소의 값이라는 것은 어떻게 알 수 있나?

gpt

그리디 알고리즘이 항상 "최적해"를 보장하지 않느다.

하지만 이 문제는 최적해를 보장하는 특성을 가지고 있따. 

그리디 선택 속성: 각 단계에서 3x3 부분 행렬을 뒤집는 선택은 로컬 최적 선택입니다. 행렬 A와 B가 특정 위치에서 다르다면, 그 위치를 포함하는 3x3 부분 행렬을 뒤집는 것이 그 위치를 동일하게 만드는 유일한 방법입니다.

역추적 불가능성: 한 번 뒤집힌 3x3 부분 행렬은 원래 상태로 돌아갈 수 없습니다. 즉, 한 위치를 기준으로 뒤집기를 수행한 후, 해당 위치는 더 이상 고려할 필요가 없습니다. 이는 각 선택이 독립적이라는 것을 의미하며, 각 선택이 전체 해결책에 직접적으로 기여합니다.

최적 부분 구조: 문제의 해결 방식은 하위 문제로 나눌 수 있으며, 이 하위 문제들의 최적 해결책이 전체 문제의 최적 해결책을 구성합니다. 3x3 부분 행렬을 뒤집는 결정은 행렬 전체에 대한 결정에 기여합니다.



그리디 선택 속성(Greedy Choice Property) 파악하기: 개인적으로 그리디 알고리즘을 관통하는 주제라고 생각한다.

로컬 최적해가의 선택의 결과가 결론적으로 글로벌 최적해로 이어 질 수 있는 문제


DP와 그리디는 경험적으로 상반되는 알고리즘이라고 느껴졌다.

이전 작은 문제가 큰 문제의 결과에 영향을 미치는 알고리즘


'''
